[{"title":"内存模型","date":"2018-09-25T14:28:16.000Z","path":"2018/09/25/mm/","text":"内存模型，英文名Memory Model，是一个跟计算机硬件相关的概念。在Java中，Java内存模型是并发编程中的重要概念，并发控制的底层逻辑和思想，都与内存模型息息相关。可以这么说，不理解内存模型，就不能真正理解Java内存模型。而讲到内存模型，要从为什么会有内存模型讲起。即：CPU高速缓存。有了高速缓存后，在普遍多核CPU下，又有了缓存一致性的问题，为了解决一致性问题，又有了缓存一致性协议。 CPU高速缓存故事要从CPU高速缓存说起。嗯，那年我18岁，她也18岁。。。啊不对，要从计算机本身说起。 \b在计算机中，执行速度\b高低以数量级递减：CPU -&gt; 主内存 -&gt; 磁盘。\b相对CPU，对主内存的\bIO是一项非常昂贵的操作。为了不让CPU在操作内存时耗费过多等待时间，人们在CPU和主内存之间增加了CPU高速缓存。缓存的作用就是保存一份数据拷贝，特点是速度快，容量小，昂贵。CPU高速缓存的速度介于CPU和主内存之间，CPU进行计算时，可以直接对高速缓存上的拷贝数据进行读取/写入操作，大大提升了CPU的执行效率。 CPU基于高速缓存执行的流程 程序及数据加载到主内存 指令和数据被加载到高速缓存 CPU执行指令，结果写回高速缓存 高速缓存的数据写回主内存 CPU每18个月运算速度翻一倍，运算速度超越了1级\b高速缓存的IO能力。为了更好的利(压)用(榨)，又引入了2级甚至3级缓存结构。在多核CPU的情况下，每个核都有自己的1级缓存。如图所示： 缓存一致性\b只有单核时，是没有问题的。当拥有多个核时，事情就变得很复杂。 当CPU0缓存了主内存某个数据的拷贝，CPU1如何知道这个数据是否被修改？即：如何保证缓存的一致性? 如何保证缓存一致性，需要多个CPU之间进行交互，这种交互的规则叫做缓存一致性协议。不同的硬件厂商有不同的缓存一致性协议,大部分协议都有很多共同点。常用的协议就是MESI。 一致性协议MESIMESI是一个很难理解的协议。同时又是很重要的协议。 我们来试试拆解成相对简单的几个概念来帮助\b理解: 状态 迁移事件 状态迁移过程 同步操作及约束 状态 缓存行（Cache Line）: 缓存存储数据的单元。 在MESI中，缓存行有以下几种状态，用2个bit表示。 状态 描述 M (Modified) 已被修改：数据有效，已被修改，与主内存中的数据不一致，只存在于本cache中 E (Exclusive) 独占：数据有效，和主内存一致 S (Shared) 共享：数据有效，和主内存一致，数据存于多个cache中 I (Invalid) 无效：这条数据无效。可能是其它cpu更改了这条数据 迁移事件缓存数据行的状态迁移事件有： 状态 描述 Local Read 本cpu读取本cache的值 Local Write 本cpu写入本cache的值 Remote Read 其它cpu读取其cache的值 Remote Write 其它cpu写入其cache的值 以当前cache为视角，针对不同状态的不同事件，我们来描述一下状态迁移过程 迁移过程 针对Modified状态的数据行 事件 行为 下一个状态 Local Read 从本cache中读取，状态不变 M Local Remote 修改本cache的数据，状态不变 M Remote Read 数据写入主内存，其它cpu读取最新的数据到其cache,状态编程Shared S Remote Write 数据写入主内存，其它核读取最新数据且被修改，状态变成Invalid I 针对Exclusive状态的数据行 事件 行为 下一个状态 Local Read 从本cache中读取，状态不变 E Local Remote 修改本cache的数据，状态变成M M Remote Read 数据被其它cpu读取到其cache,状态编程Shared S Remote Write 数据被其它cpu修改，状态变成Invalid I 针对Shared状态的数据行 事件 行为 下一个状态 Local Read 从本cache中读取，状态不变 S Local Remote 修改本cache的数据，状态变成M M Remote Read 数据被其它cpu读取到其cache,状态不变 S Remote Write 数据被其它cpu修改，状态变成Invalid I 针对Invalid状态的数据行 事件 行为 下一个状态 Local Read 如果其它cache无此数据，本cache从主内存读取，状态变成E；如果其它cache有，状态变成S E/S Local Remote 修改本cache的数据，状态变成M M Remote Read 数据被其它cpu读取到其cache,状态编程Shared S Remote Write 数据被其它cpu修改，状态变成Invalid I 同步操作及约束上面我们描述了不同\bMESI各种状态，迁移事件，以及状态迁移过程。","categories":[{"name":"JVM","slug":"JVM","permalink":"http://humin.me/categories/JVM/"}],"tags":[{"name":"Mermory Model","slug":"Mermory-Model","permalink":"http://humin.me/tags/Mermory-Model/"}]}]