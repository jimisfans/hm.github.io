[{"title":"内存模型","date":"2018-09-25T14:28:16.000Z","path":"2018/09/25/mm/","text":"内存模型，英文名Memory Model，是一个跟计算机硬件相关的概念。在Java中，Java内存模型是并发编程中的重要概念，并发控制的底层逻辑和思想，都与内存模型息息相关。可以这么说，不理解内存模型，就不能真正理解Java内存模型。而讲到内存模型，要从为什么会有内存模型讲起。即：CPU高速缓存。有了高速缓存后，在普遍多核CPU下，又有了缓存一致性的问题，为了解决一致性问题，又有了缓存一致性协议。 CPU高速缓存故事要从CPU高速缓存说起。嗯，那年我18岁，她也18岁。。。啊不对，要从计算机本身说起。 \b在计算机中，执行速度\b高低以数量级递减：CPU -&gt; 主内存 -&gt; 磁盘。\b相对CPU，对主内存的\bIO是一项非常昂贵的操作。为了不让CPU在操作内存时耗费过多等待时间，人们在CPU和主内存之间增加了CPU高速缓存。缓存的作用就是保存一份数据拷贝，特点是速度快，容量小，昂贵。CPU高速缓存的速度介于CPU和主内存之间，CPU进行计算时，可以直接对高速缓存上的拷贝数据进行读取/写入操作，大大提升了CPU的执行效率。 CPU基于高速缓存执行的流程 程序及数据加载到主内存 指令和数据被加载到高速缓存 CPU执行指令，结果写回高速缓存 高速缓存的数据写回主内存 CPU每18个月运算速度翻一倍，运算速度超越了1级\b高速缓存的IO能力。为了更好的利(压)用(榨)，又引入了2级甚至3级缓存结构。在多核CPU的情况下，每个核都有自己的1级缓存。如图所示： 缓存一致性\b只有单核时，是没有问题的。当拥有多个核时，事情就变得很复杂。 当CPU0缓存了主内存某个数据的拷贝，CPU1如何知道这个数据是否被修改？即：如何保证缓存的一致性? 如何保证缓存一致性，需要多个CPU之间进行交互，这种交互的规则叫做缓存一致性协议。不同的硬件厂商有不同的缓存一致性协议,大部分协议都有很多共同点。常用的协议就是MESI。 一致性协议: MESIMESI是4种状态首字母的组合。我们可以把MESI理解为基于状态的一致性协议。 我们来试试拆解成相对简单的几个概念来帮助\b理解: 状态 触发事件 状态迁移 同步操作及约束 状态 缓存行（Cache Line）: 缓存存储数据的单元。在MESI中，缓存行有M/E/S/I四种状态，用2个bit表示。 状态 描述 M (Modified) 修改：数据有效，已被修改，与主内存中的数据不一致，只存在于本cache中 E (Exclusive) 独占：数据有效，和主内存一致 S (Shared) 共享：数据有效，和主内存一致，数据存于多个cache中 I (Invalid) 无效：这条数据无效。可能是其它cpu更改了这条数据 触发事件缓存行的状态\b的变更，是由触发事件触发，事件有4种： 事件 描述 \b触发源 本地读取 Local Read 本地cache读取本地cache的值 本地cache 本地写入 Local Write 本地cache写入本地cache的值 本地cache 远端读取 Remote Read 其它cache读取本地cache的值 remote cache 远端写入 Remote Write 其它cache写入本地cache的值 remote cache 注： 迁移事件描述是以本地cache为视角。 状态迁移我们假设有一条缓存行被所有cache共同缓存了。针对这条缓存行，我们以不同的cache为视角，在每个状态时，触发了每一种事件后，状态迁移过程。 名词解释： 本地cache: 指当前cache 触发cache: 指触发读写事件的cache 其它cache: 指除了本地cache和触发cache外的其它cache 注意：local read, local write两种本地事件，本地cache和触发cache相同 当前状态 Local Read Local Write Remote Read Remote Write M 本地cache/触发cache: M其它cache:I 本地cache/触发cache:M其它cache:I 本地cache:M-&gt;E-&gt;S-&gt;触发cache\b:I-&gt;S其它cache:I \b本地cache:M-&gt;E-&gt;S-&gt;I\b触发cache:I-&gt;S-&gt;E-&gt;M其它cache:I E 本地cache/触发cache:E其它cache:I 本地cache/触发cache:E-&gt;M其它cache:I 本地cache:E-&gt;S\b触发cache:I-&gt;S其它cache:I 本地cache:E-&gt;S-&gt;I触发cache:I-&gt;S-&gt;E-&gt;M其它cache:I S 本地cache/触发cache:S其它cache:S 本地cache/触发cache/其它cache:S 本地cache/其它cache:E-&gt;I触发cache:S-&gt;E-&gt;M 本地cache:S-&gt;I触发cache:S-&gt;E-&gt;M其它cache:S-&gt;I I 本地cache/\b触发cache:I-&gt;S或者EE、M、I-&gt;S 本地cache/触发cache:I-&gt;S-&gt;E-&gt;M其它cache:M、E、S、I-&gt;I 不变 不\b变 同步操作及约束上面我们描述了不同\bMESI各种状态，迁移事件，以及状态迁移过程。","categories":[{"name":"JVM","slug":"JVM","permalink":"http://humin.me/categories/JVM/"}],"tags":[{"name":"Mermory Model","slug":"Mermory-Model","permalink":"http://humin.me/tags/Mermory-Model/"}]}]